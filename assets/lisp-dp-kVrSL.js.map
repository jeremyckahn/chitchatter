{"version":3,"file":"lisp-dp-kVrSL.js","sources":["../../node_modules/refractor/lang/lisp.js"],"sourcesContent":["'use strict'\n\nmodule.exports = lisp\nlisp.displayName = 'lisp'\nlisp.aliases = []\nfunction lisp(Prism) {\n  ;(function (Prism) {\n    /**\n     * Functions to construct regular expressions\n     * e.g. (interactive ... or (interactive)\n     *\n     * @param {string} name\n     * @returns {RegExp}\n     */\n    function simple_form(name) {\n      return RegExp(/(\\()/.source + '(?:' + name + ')' + /(?=[\\s\\)])/.source)\n    }\n    /**\n     * booleans and numbers\n     *\n     * @param {string} pattern\n     * @returns {RegExp}\n     */\n    function primitive(pattern) {\n      return RegExp(\n        /([\\s([])/.source + '(?:' + pattern + ')' + /(?=[\\s)])/.source\n      )\n    } // Patterns in regular expressions\n    // Symbol name. See https://www.gnu.org/software/emacs/manual/html_node/elisp/Symbol-Type.html\n    // & and : are excluded as they are usually used for special purposes\n    var symbol = /(?!\\d)[-+*/~!@$%^=<>{}\\w]+/.source // symbol starting with & used in function arguments\n    var marker = '&' + symbol // Open parenthesis for look-behind\n    var par = '(\\\\()'\n    var endpar = '(?=\\\\))' // End the pattern with look-ahead space\n    var space = '(?=\\\\s)'\n    var nestedPar =\n      /(?:[^()]|\\((?:[^()]|\\((?:[^()]|\\((?:[^()]|\\((?:[^()]|\\([^()]*\\))*\\))*\\))*\\))*\\))*/\n        .source\n    var language = {\n      // Three or four semicolons are considered a heading.\n      // See https://www.gnu.org/software/emacs/manual/html_node/elisp/Comment-Tips.html\n      heading: {\n        pattern: /;;;.*/,\n        alias: ['comment', 'title']\n      },\n      comment: /;.*/,\n      string: {\n        pattern: /\"(?:[^\"\\\\]|\\\\.)*\"/,\n        greedy: true,\n        inside: {\n          argument: /[-A-Z]+(?=[.,\\s])/,\n          symbol: RegExp('`' + symbol + \"'\")\n        }\n      },\n      'quoted-symbol': {\n        pattern: RegExp(\"#?'\" + symbol),\n        alias: ['variable', 'symbol']\n      },\n      'lisp-property': {\n        pattern: RegExp(':' + symbol),\n        alias: 'property'\n      },\n      splice: {\n        pattern: RegExp(',@?' + symbol),\n        alias: ['symbol', 'variable']\n      },\n      keyword: [\n        {\n          pattern: RegExp(\n            par +\n              '(?:and|(?:cl-)?letf|cl-loop|cond|cons|error|if|(?:lexical-)?let\\\\*?|message|not|null|or|provide|require|setq|unless|use-package|when|while)' +\n              space\n          ),\n          lookbehind: true\n        },\n        {\n          pattern: RegExp(\n            par +\n              '(?:append|by|collect|concat|do|finally|for|in|return)' +\n              space\n          ),\n          lookbehind: true\n        }\n      ],\n      declare: {\n        pattern: simple_form(/declare/.source),\n        lookbehind: true,\n        alias: 'keyword'\n      },\n      interactive: {\n        pattern: simple_form(/interactive/.source),\n        lookbehind: true,\n        alias: 'keyword'\n      },\n      boolean: {\n        pattern: primitive(/nil|t/.source),\n        lookbehind: true\n      },\n      number: {\n        pattern: primitive(/[-+]?\\d+(?:\\.\\d*)?/.source),\n        lookbehind: true\n      },\n      defvar: {\n        pattern: RegExp(par + 'def(?:const|custom|group|var)\\\\s+' + symbol),\n        lookbehind: true,\n        inside: {\n          keyword: /^def[a-z]+/,\n          variable: RegExp(symbol)\n        }\n      },\n      defun: {\n        pattern: RegExp(\n          par +\n            /(?:cl-)?(?:defmacro|defun\\*?)\\s+/.source +\n            symbol +\n            /\\s+\\(/.source +\n            nestedPar +\n            /\\)/.source\n        ),\n        lookbehind: true,\n        greedy: true,\n        inside: {\n          keyword: /^(?:cl-)?def\\S+/,\n          // See below, this property needs to be defined later so that it can\n          // reference the language object.\n          arguments: null,\n          function: {\n            pattern: RegExp('(^\\\\s)' + symbol),\n            lookbehind: true\n          },\n          punctuation: /[()]/\n        }\n      },\n      lambda: {\n        pattern: RegExp(\n          par +\n            'lambda\\\\s+\\\\(\\\\s*(?:&?' +\n            symbol +\n            '(?:\\\\s+&?' +\n            symbol +\n            ')*\\\\s*)?\\\\)'\n        ),\n        lookbehind: true,\n        greedy: true,\n        inside: {\n          keyword: /^lambda/,\n          // See below, this property needs to be defined later so that it can\n          // reference the language object.\n          arguments: null,\n          punctuation: /[()]/\n        }\n      },\n      car: {\n        pattern: RegExp(par + symbol),\n        lookbehind: true\n      },\n      punctuation: [\n        // open paren, brackets, and close paren\n        /(?:['`,]?\\(|[)\\[\\]])/, // cons\n        {\n          pattern: /(\\s)\\.(?=\\s)/,\n          lookbehind: true\n        }\n      ]\n    }\n    var arg = {\n      'lisp-marker': RegExp(marker),\n      varform: {\n        pattern: RegExp(\n          /\\(/.source + symbol + /\\s+(?=\\S)/.source + nestedPar + /\\)/.source\n        ),\n        inside: language\n      },\n      argument: {\n        pattern: RegExp(/(^|[\\s(])/.source + symbol),\n        lookbehind: true,\n        alias: 'variable'\n      },\n      rest: language\n    }\n    var forms = '\\\\S+(?:\\\\s+\\\\S+)*'\n    var arglist = {\n      pattern: RegExp(par + nestedPar + endpar),\n      lookbehind: true,\n      inside: {\n        'rest-vars': {\n          pattern: RegExp('&(?:body|rest)\\\\s+' + forms),\n          inside: arg\n        },\n        'other-marker-vars': {\n          pattern: RegExp('&(?:aux|optional)\\\\s+' + forms),\n          inside: arg\n        },\n        keys: {\n          pattern: RegExp('&key\\\\s+' + forms + '(?:\\\\s+&allow-other-keys)?'),\n          inside: arg\n        },\n        argument: {\n          pattern: RegExp(symbol),\n          alias: 'variable'\n        },\n        punctuation: /[()]/\n      }\n    }\n    language['lambda'].inside.arguments = arglist\n    language['defun'].inside.arguments = Prism.util.clone(arglist)\n    language['defun'].inside.arguments.inside.sublist = arglist\n    Prism.languages.lisp = language\n    Prism.languages.elisp = language\n    Prism.languages.emacs = language\n    Prism.languages['emacs-lisp'] = language\n  })(Prism)\n}\n"],"names":["lisp_1","lisp","Prism","simple_form","name","primitive","pattern","symbol","marker","par","endpar","space","nestedPar","language","arg","forms","arglist"],"mappings":"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","x_google_ignoreList":[0]}